from typing import Optional, Dict, Any, AsyncIterator, List
from datetime import datetime
from ..models.calls import ListCallsParams, UpdateCallParams
from ..utils.datetime import to_api_datetime, convert_dict_datetimes

class Calls:
    def __init__(self, client):
        self.client = client

    async def list(
        self,
        fetch_queue_data: bool = False,
        fetch_ai_data: bool = False,
        from_datetime: Optional[datetime] = None,
        to_datetime: Optional[datetime] = None,
        contact_number: Optional[str] = None,
        justcall_number: Optional[str] = None,
        agent_id: Optional[int] = None,
        ivr_digit: Optional[int] = None,
        call_direction: Optional[str] = None,
        call_type: Optional[str] = None,
        call_traits: Optional[List[str]] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = 20,
        sort: str = "id",
        order: str = "desc",
        last_call_id_fetched: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        List all calls with optional filtering parameters.
        Returns a paginated list of calls based on the provided filters.
        """
        params = ListCallsParams(
            fetch_queue_data=fetch_queue_data,
            fetch_ai_data=fetch_ai_data,
            from_datetime=from_datetime,
            to_datetime=to_datetime,
            contact_number=contact_number,
            justcall_number=justcall_number,
            agent_id=agent_id,
            ivr_digit=ivr_digit,
            call_direction=call_direction,
            call_type=call_type,
            call_traits=call_traits,
            page=page,
            per_page=per_page,
            sort=sort,
            order=order,
            last_call_id_fetched=last_call_id_fetched
        )

        response = await self.client._make_request(
            method="GET",
            endpoint="/v2.1/calls",
            params=params.model_dump(exclude_none=True)
        )
        
        # Convert datetime strings in response to Python datetime objects
        return convert_dict_datetimes(response)

    async def get(
        self,
        call_id: int,
        fetch_queue_data: bool = False,
        fetch_ai_data: bool = False
    ) -> Dict[str, Any]:
        """
        Get details of a specific call by ID.
        
        Args:
            call_id (int): Unique ID of the call generated by JustCall
            fetch_queue_data (bool): Set to true to fetch queue data like callback time, status, etc.
            fetch_ai_data (bool): Set to true to fetch coaching data by JustCall AI
            
        Returns:
            Dict[str, Any]: Call details
        """
        params = {
            "fetch_queue_data": fetch_queue_data,
            "fetch_ai_data": fetch_ai_data
        }

        return await self.client._make_request(
            method="GET",
            endpoint=f"/v2.1/calls/{call_id}",
            params=params
        )

    async def update(
        self,
        call_id: int,
        notes: Optional[str] = None,
        disposition_code: Optional[str] = None,
        rating: Optional[float] = None
    ) -> Dict[str, Any]:
        """
        Update a call's details.
        
        Args:
            call_id (int): Unique ID of the call
            notes (str, optional): New notes for the call (replaces existing)
            disposition_code (str, optional): New disposition code
            rating (float, optional): New rating (0-5, allows .5 increments)
            
        Returns:
            Dict[str, Any]: Updated call details
        """
        params = UpdateCallParams(
            notes=notes,
            disposition_code=disposition_code,
            rating=rating
        )

        return await self.client._make_request(
            method="PUT",
            endpoint=f"/v2.1/calls/{call_id}",
            json=params.model_dump(exclude_none=True)
        )

    async def get_journey(
        self,
        call_id: int
    ) -> Dict[str, Any]:
        """
        Get the journey/timeline of a specific call.
        
        Args:
            call_id (int): Unique ID of the call generated by JustCall
            
        Returns:
            Dict[str, Any]: Call journey details
        """
        return await self.client._make_request(
            method="GET",
            endpoint=f"/v2.1/calls/{call_id}/journey"
        )

    async def get_voice_agent_data(
        self,
        call_id: int
    ) -> Dict[str, Any]:
        """
        Get voice agent data for a specific call.
        
        Args:
            call_id (int): Unique ID of the call generated by JustCall
            
        Returns:
            Dict[str, Any]: Voice agent data for the call
        """
        return await self.client._make_request(
            method="GET",
            endpoint=f"/v2.1/calls/{call_id}/voice-agent"
        )

    async def download_recording(
        self,
        call_id: int
    ) -> bytes:
        """
        Download the recording for a specific call.
        
        Args:
            call_id (int): Unique ID of the call generated by JustCall
            
        Returns:
            bytes: The recording file data
            
        Raises:
            JustCallException: If the recording doesn't exist or other API errors
        """
        return await self.client._make_request(
            method="GET",
            endpoint=f"/v2.1/calls/{call_id}/recording/download",
            expect_json=False  # We expect binary data, not JSON
        )

    async def iter_all(
        self,
        fetch_queue_data: bool = False,
        fetch_ai_data: bool = False,
        from_datetime: Optional[datetime] = None,
        to_datetime: Optional[datetime] = None,
        contact_number: Optional[str] = None,
        justcall_number: Optional[str] = None,
        agent_id: Optional[int] = None,
        ivr_digit: Optional[int] = None,
        call_direction: Optional[str] = None,
        call_type: Optional[str] = None,
        call_traits: Optional[List[str]] = None,
        sort: str = "id",
        order: str = "desc",
        max_items: Optional[int] = None
    ) -> AsyncIterator[Dict[str, Any]]:
        """
        Iterate through all calls matching the filter criteria.
        Automatically handles pagination.
        
        Args:
            Same as list() method, except page and per_page are handled internally
            max_items: Maximum number of items to return (None for all)
            
        Yields:
            Dict[str, Any]: Individual call records
        """
        params = ListCallsParams(
            fetch_queue_data=fetch_queue_data,
            fetch_ai_data=fetch_ai_data,
            from_datetime=from_datetime,
            to_datetime=to_datetime,
            contact_number=contact_number,
            justcall_number=justcall_number,
            agent_id=agent_id,
            ivr_digit=ivr_digit,
            call_direction=call_direction,
            call_type=call_type,
            call_traits=call_traits,
            sort=sort,
            order=order,
            per_page=100  # Use maximum allowed per_page for efficiency
        )

        async for item in self.client._paginate(
            method="GET",
            endpoint="/v2.1/calls",
            params=params.model_dump(exclude_none=True),
            max_items=max_items
        ):
            # Convert datetime strings in each item to Python datetime objects
            yield convert_dict_datetimes(item)
