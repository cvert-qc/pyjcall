from typing import Optional, Dict, Any, AsyncIterator, List
from ..models.campaign_contacts import (
    GetCustomFieldsParams,
    ListCampaignContactsParams,
    AddCampaignContactParams,
    RemoveCampaignContactParams
)

class CampaignContacts:
    def __init__(self, client):
        self.client = client

    async def get_custom_fields(self) -> Dict[str, Any]:
        """
        Get custom fields for campaign contacts.
        
        Returns:
            Dict[str, Any]: List of custom fields with their labels, keys, and types
        """
        params = GetCustomFieldsParams()

        return await self.client._make_request(
            method="POST",
            endpoint="/v1/autodialer/contacts/customfields",
            json=params.model_dump(exclude_none=True)
        )

    async def list(
        self,
        campaign_id: str,
        contact_status: Optional[str] = None,
        progress_status: Optional[str] = None,
        page: Optional[int] = None,
        per_page: Optional[int] = None,
        order: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        List contacts in a campaign with pagination support using v2 API.
        
        Args:
            campaign_id (str): Unique id of the campaign generated by Sales Dialer
            contact_status (str, optional): Filter based on contact status ('Active', 'DNCA', or 'Invalid')
            progress_status (str, optional): Filter based on progress status ('Dialed', 'Undialed', or 'Skipped')
            page (int, optional): Page number to retrieve (default: 0)
            per_page (int, optional): Number of results per page (default: 10)
            order (str, optional): Order of results ('asc' or 'desc', default: 'desc')
            
        Returns:
            Dict[str, Any]: List of contacts in the campaign
        """
        params = ListCampaignContactsParams(
            campaign_id=campaign_id,
            contact_status=contact_status,
            progress_status=progress_status,
            page=page,
            per_page=per_page,
            order=order
        )

        return await self.client._make_request(
            method="GET",
            endpoint="/v2.1/sales_dialer/campaigns/contacts",
            params=params.model_dump(exclude_none=True)
        )

    async def add(
        self,
        campaign_id: str,
        phone: str,
        first_name: Optional[str] = None,
        last_name: Optional[str] = None,
        custom_props: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Add a contact to a campaign.
        
        Args:
            campaign_id (str): Campaign ID to which the contact will be added
            phone (str): Formatted phone number of the contact with country code
            first_name (str, optional): Contact's first name
            last_name (str, optional): Contact's last name
            custom_props (Dict[str, Any], optional): Custom properties for the contact
            
        Returns:
            Dict[str, Any]: Added contact details
        """
        params = AddCampaignContactParams(
            campaign_id=campaign_id,
            phone=phone,
            first_name=first_name,
            last_name=last_name,
            custom_props=custom_props
        )

        return await self.client._make_request(
            method="POST",
            endpoint="/v1/autodialer/campaigns/add",
            json=params.model_dump(exclude_none=True)
        )

    async def remove(
        self,
        campaign_id: Optional[str] = None,
        phone: Optional[str] = None,
        all: Optional[bool] = None
    ) -> Dict[str, Any]:
        """
        Remove a contact from a campaign.
        
        Args:
            campaign_id (str, optional): Campaign ID from which to remove the contact
            phone (str, optional): Phone number of the contact to remove
            all (bool, optional): If true, removes all contacts from the campaign
            
        Returns:
            Dict[str, Any]: Response with status and message
            
        Note:
            - If only phone is provided, the contact will be removed from all campaigns
            - If all=True, all contacts will be removed from the specified campaign
        """
        params = RemoveCampaignContactParams(
            campaign_id=campaign_id,
            phone=phone,
            all=all
        )

        return await self.client._make_request(
            method="POST",
            endpoint="/v1/autodialer/contacts/remove",
            json=params.model_dump(exclude_none=True)
        )

    async def iter_all(
        self,
        campaign_id: str,
        contact_status: Optional[str] = None,
        progress_status: Optional[str] = None,
        order: Optional[str] = None,
        max_items: Optional[int] = None
    ) -> AsyncIterator[Dict[str, Any]]:
        """
        Iterate through all contacts in a campaign with pagination support using v2 API.
        
        Args:
            campaign_id (str): Unique id of the campaign generated by Sales Dialer
            contact_status (str, optional): Filter based on contact status ('Active', 'DNCA', or 'Invalid')
            progress_status (str, optional): Filter based on progress status ('Dialed', 'Undialed', or 'Skipped')
            order (str, optional): Order of results ('asc' or 'desc', default: 'desc')
            max_items (int, optional): Maximum number of items to return (None for all)
            
        Yields:
            Dict[str, Any]: Individual contact records
        """
        count = 0
        page = 0  # v2 API starts with page 0
        per_page = 10  # Default for v2 API
        
        while True:
            response = await self.list(
                campaign_id=campaign_id,
                contact_status=contact_status,
                progress_status=progress_status,
                page=page,
                per_page=per_page,
                order=order
            )
            
            items = response.get("data", [])
            if not items:
                break
                
            for item in items:
                if max_items and count >= max_items:
                    return
                yield item
                count += 1
                
            # Check if we've reached the last page
            if len(items) < per_page:
                break
                
            page += 1
